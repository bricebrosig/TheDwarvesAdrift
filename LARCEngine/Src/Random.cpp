/// \file Random.cpp
/// \brief Code for the pseudorandom number generator CRandom.

#include "random.h"
#include "Timer.h"
#include "Helpers.h"

/// This constructor seeds the PRNG with an unpredictable
/// value drawn from a timer.

CRandom::CRandom(){ 
  srand(); //seed PRNG from timer
} //constructor

/// If the seed is negative (which it is by default
/// if no parameter is supplied), then use the raw time
/// of day, which is assumed to be somewhat unpredictable.
/// The state variables for xorshift128 are initialized using
/// the C Standard Library function rand() which is
/// seeded using the pro-offered seed value.
/// \param seed The seed, defaults to -1.

void CRandom::srand(int seed){ 
  ::srand((seed >= 0)? seed: m_pTimer->rawtime() & 0x7FFF);

  m_uState[0] = m_pTimer->rawtime() & 0xFFFFFFFF;

  for(int i=1; i<=3; i++)
    m_uState[i] = m_uState[i - 1]*(unsigned)::rand();
} //srand

/// Generate a pseudorandom unsigned integer using xorshift128.
/// This is the one that does the actual work here: The other
/// psuedorandom generation functions rely on this one.
/// Algorithm snarfed from the interwebs.
/// \return A pseudorandom unsigned integer.

unsigned CRandom::randn(){ 
	unsigned s = m_uState[3];

	s ^= s << 11;
	s ^= s >> 8;

	m_uState[3] = m_uState[2]; 
  m_uState[2] = m_uState[1]; 
  m_uState[1] = m_uState[0];

	s ^= m_uState[0];
	s ^= m_uState[0] >> 19;	

	m_uState[0] = s;

	return s;
} //randn

/// Generate a pseudorandom unsigned integer within a given range.
/// \param i Bottom of range.
/// \param j Top of range.
/// \return A random positive integer r such that i \f$\leq\f$ r \f$\leq\f$ j.

unsigned CRandom::randn(unsigned i, unsigned j){  
  return randn()%(j - i + 1) + i;
} //randn

/// Generate a pseudorandom floating positive point number 
/// in \f$[0,1]\f$by generatings a pseudorandom unsigned
/// integer and dividing it by \f$2^{32} - 1\f$.
/// \return A pseudorandom floating point number from \f$[0,1]\f$.

float CRandom::randf(){
  return (float)randn()/(float)0xFFFFFFFF;
} //randf

/// Generate a pseudorandom unit vector by generating an
/// angle in the range \f$[0, 2\pi]\f$ and returning the unit vector
/// with that orientation.
/// \return A pseudorandom unit vector.

Vector2 CRandom::randv(){
  const float a = XM_2PI*randf(); //random angle between 0 and \f$2\pi\f$.
  return Vector2(cos(a), sin(a)); //convert to unit vector
} //randv

/// Generate an aesthetically pleasing pseudorandom color 
/// by generating a color in HSV format with random hue,
/// saturation 0.5, and value 1.0 and then converting that 
/// to RGB. HSV is used because colors are better distributed in
/// HSV-space than in RGB-space. There will probably be a lot of 
/// repeated colors generated by this function but probably not
/// consecutively. The colors generated will be light and bright
/// highly unlikely to be gray. The alpha value is set to 1, that
/// is, there is no transparency.
/// \return A hopefully aesthetically pleasing pseudorandom color.

XMFLOAT4 CRandom::randclr(){
  return HSVtoRGB(randf(), 0.5f, 1.0f); //generate color in HSV format and convert to RGB
} //randclr

/// \return A pointer to an array of 16 pseudo-random bytes (128 random bits)
 
BYTE* CRandom::rand128(){
  randn();
  return (BYTE*)m_uState;
} //rand128
